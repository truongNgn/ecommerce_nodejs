const Order = require('../models/Order');
const Cart = require('../models/Cart');
const User = require('../models/User');
const asyncHandler = require('../middleware/async');
const AppError = require('../middleware/errorResponse');

// @desc    Create new order
// @route   POST /api/orders
// @access  Public
const createOrder = asyncHandler(async (req, res) => {
  const { 
    shippingAddress, 
    paymentMethod, 
    discountCode, 
    loyaltyPointsUsed, 
    guestInfo,
    items,
    subtotal,
    tax,
    shipping,
    discount,
    total
  } = req.body;

  let user = req.user;
  let cart;

  // Handle guest checkout
  if (!user && guestInfo) {
    // Check if user with this email already exists
    let existingUser = await User.findOne({ email: guestInfo.email });
    
    if (!existingUser) {
      // Create new user account automatically
      existingUser = await User.create({
        email: guestInfo.email,
        fullName: guestInfo.fullName,
        phone: guestInfo.phone,
        password: Math.random().toString(36).slice(-8), // Random password
        role: 'user',
        isEmailVerified: false
      });
    }
    
    user = existingUser;
  }

  // Get cart (for authenticated users) or use items from request body (for guests)
  if (req.user) {
    cart = await Cart.findByUser(req.user.id);
    if (!cart || cart.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: 'Cart is empty'
      });
    }
    // Populate cart items with product details
    await cart.populate({
      path: 'items.product',
      select: 'name images brand category basePrice variants totalStock'
    });
  }

  // Prepare order data (orderNumber will be generated by pre-save middleware)
  const orderData = {
    status: 'pending', // Set default status
    paymentMethod,
    subtotal: cart ? cart.subtotal : subtotal,
    tax: cart ? cart.tax : tax,
    shipping: cart ? cart.shipping : shipping,
    discount: cart ? cart.discount : discount,
    total: cart ? cart.total : total,
    discountCode: cart ? cart.discountCode : discountCode,
    loyaltyPointsUsed: cart ? cart.loyaltyPointsUsed : loyaltyPointsUsed
  };

  // Add user or guest info
  if (user) {
    orderData.user = user._id;
  } else if (guestInfo) {
    orderData.guestInfo = guestInfo;
  }

  // Parse shipping address - Frontend sends string, convert to required object
  const addressParts = typeof shippingAddress === 'string' 
    ? shippingAddress.split(',').map(s => s.trim()) 
    : [];
  
  orderData.shippingAddress = {
    fullName: guestInfo?.fullName || user?.fullName || 'Customer',
    street: typeof shippingAddress === 'string' ? shippingAddress : (shippingAddress?.street || 'N/A'),
    city: addressParts[addressParts.length - 2] || shippingAddress?.city || 'Ho Chi Minh City',
    state: addressParts[addressParts.length - 1] || shippingAddress?.state || 'Ho Chi Minh',
    zipCode: shippingAddress?.zipCode || '700000',
    country: shippingAddress?.country || 'Vietnam'
  };

  // Add items - Map cart items to order items with required fields
  if (cart && cart.items && cart.items.length > 0) {
    orderData.items = cart.items.map(item => {
      const product = item.product;
      const variant = item.variant;
      
      // Find variant data from product.variants if variant ID exists
      let variantData = null;
      if (variant && product.variants && product.variants.length > 0) {
        variantData = product.variants.find(v => 
          v._id && variant._id && v._id.toString() === variant._id.toString()
        );
      }
      
      return {
        product: product._id || product,
        variant: variant?._id || null,
        productName: product.name || 'Product',
        variantName: variantData?.name || variant?.name || 'Standard',
        quantity: item.quantity || 1,
        price: variantData?.price || variant?.price || product.basePrice || 0,
        total: (variantData?.price || variant?.price || product.basePrice || 0) * (item.quantity || 1)
      };
    });
  } else if (items && items.length > 0) {
    orderData.items = items.map(item => ({
      product: item.product?._id || item.product,
      variant: item.variant?._id || null,
      productName: item.product?.name || item.productName || 'Product',
      variantName: item.variant?.name || item.variantName || 'Standard',
      quantity: item.quantity || 1,
      price: item.variant?.price || item.product?.basePrice || item.price || 0,
      total: (item.variant?.price || item.product?.basePrice || item.price || 0) * (item.quantity || 1)
    }));
  } else {
    return res.status(400).json({
      success: false,
      message: 'No items to order'
    });
  }

  // Debug log
  console.log('üì¶ Creating order with data:', JSON.stringify({
    orderNumber: orderData.orderNumber,
    user: orderData.user,
    guestInfo: orderData.guestInfo,
    shippingAddress: orderData.shippingAddress,
    items: orderData.items.length,
    itemsSample: orderData.items[0]
  }, null, 2));

  // Create order
  console.log('üì¶ Order data before creation:', JSON.stringify({
    orderNumber: orderData.orderNumber,
    status: orderData.status || 'pending',
    user: orderData.user,
    guestInfo: orderData.guestInfo,
    itemsCount: orderData.items?.length || 0
  }, null, 2));
  
  const order = await Order.create(orderData);
  
  console.log('üì¶ Order created successfully:', {
    id: order._id,
    orderNumber: order.orderNumber,
    status: order.status
  });

  // Calculate loyalty points earned (10% of total)
  if (order.calculateLoyaltyPoints) {
    await order.calculateLoyaltyPoints();
    console.log('üéÅ Loyalty points calculated:', {
      orderTotal: order.total,
      loyaltyPointsEarned: order.loyaltyPointsEarned
    });
  }

  // Add loyalty points to user (if authenticated)
  if (user && user.addLoyaltyPoints && order.loyaltyPointsEarned) {
    console.log('üéÅ Adding loyalty points to user:', {
      userId: user._id,
      pointsToAdd: order.loyaltyPointsEarned,
      currentPoints: user.loyaltyPoints
    });
    await user.addLoyaltyPoints(order.loyaltyPointsEarned);
    console.log('üéÅ Loyalty points added successfully');
  }

  // Mark discount code as used (if applicable)
  if (orderData.discountCode && orderData.discount > 0) {
    const DiscountCode = require('../models/DiscountCode');
    const discount = await DiscountCode.findByCode(orderData.discountCode);
    if (discount) {
      try {
        await discount.useCode(user?._id, order._id, orderData.discount);
      } catch (error) {
        console.error('Failed to mark discount code as used:', error.message);
      }
    }
  }

  // Deduct loyalty points from user (if used)
  if (user && orderData.loyaltyPointsUsed > 0) {
    try {
      // Convert VND back to points: loyaltyPointsUsed is in VND, need to convert to points
      const pointsUsed = Math.floor(orderData.loyaltyPointsUsed / 1000);
      console.log('üéÅ Deducting loyalty points from user:', {
        userId: user._id,
        loyaltyPointsUsedVND: orderData.loyaltyPointsUsed,
        pointsUsed: pointsUsed,
        currentPoints: user.loyaltyPoints
      });
      await user.useLoyaltyPoints(pointsUsed);
      console.log('üéÅ Loyalty points deducted successfully');
    } catch (error) {
      console.error('Failed to deduct loyalty points:', error.message);
    }
  }

  // Clear cart (if authenticated)
  if (cart) {
    await cart.clearCart();
  }

  // Send order confirmation email via queue (async processing)
  try {
    const { addEmailJob } = require('../services/queue/emailQueue');
    
    // Prepare user data for email
    const emailUser = user || {
      email: guestInfo.email,
      fullName: guestInfo.fullName
    };
    
    // Add email job to queue (non-blocking)
    await addEmailJob('order-confirmation', {
      order: {
        _id: order._id,
        orderNumber: order.orderNumber,
        createdAt: order.createdAt,
        total: order.total,
        status: order.status,
        items: order.items.map(item => ({
          productName: item.productName,
          variantName: item.variantName,
          quantity: item.quantity,
          price: item.price,
          total: item.total
        })),
        shippingAddress: order.shippingAddress,
        paymentMethod: order.paymentMethod
      },
      user: emailUser
    }, {
      priority: 2, // High priority for order confirmations
      attempts: 3
    });
    
    console.log(`üì® Order confirmation email queued for: ${emailUser.email}`);
  } catch (error) {
    // Log error but don't fail the order creation
    console.error('‚ùå Failed to queue order confirmation email:', error.message);
    console.log('‚ö†Ô∏è Order created successfully but email notification failed');
    
    // Try direct email send as fallback
    try {
      const { sendEmail } = require('../services/emailService');
      const customerEmail = user ? user.email : guestInfo.email;
      const customerName = user ? user.fullName : guestInfo.fullName;
      
      const emailMessage = `
Dear ${customerName},

Thank you for your order! Your order has been successfully placed.

Order Details:
- Order Number: ${order.orderNumber}
- Order Date: ${order.createdAt.toLocaleDateString()}
- Total Amount: ${order.total.toLocaleString()} VND
- Status: ${order.status}

Items Ordered:
${order.items.map(item => `- ${item.productName} (${item.variantName}) x${item.quantity} = ${item.total.toLocaleString()} VND`).join('\n')}

We will process your order and send you updates via email.

Thank you for choosing our store!

Best regards,
TechStore Team
      `;
      
      await sendEmail({
        email: customerEmail,
        subject: `Order Confirmation - ${order.orderNumber}`,
        message: emailMessage
      });
      
      console.log('üìß Order confirmation email sent directly (fallback):', customerEmail);
    } catch (fallbackError) {
      console.error('‚ùå Fallback email also failed:', fallbackError.message);
      // Continue - order is still created successfully
    }
  }

  res.status(201).json({
    success: true,
    message: 'Order created successfully',
    data: { order }
  });
});

// @desc    Get user orders
// @route   GET /api/orders/my
// @access  Private
const getMyOrders = asyncHandler(async (req, res) => {
  const { status, page = 1, limit = 10 } = req.query;
  
  const pageNum = parseInt(page);
  const limitNum = parseInt(limit);
  
  const filter = { user: req.user.id };
  if (status) filter.status = status;
  
  const orders = await Order.find(filter)
    .sort({ createdAt: -1 })
    .limit(limitNum)
    .skip((pageNum - 1) * limitNum)
    .populate('items.product', 'name images');
  
  const total = await Order.countDocuments(filter);
  const totalPages = Math.ceil(total / limitNum);
  const hasNextPage = pageNum < totalPages;
  const hasPrevPage = pageNum > 1;
  
  // Debug logging
  console.log('üì¶ User orders debug:', {
    userId: req.user.id,
    filter,
    ordersCount: orders.length,
    orders: orders.map(order => ({
      id: order._id,
      orderNumber: order.orderNumber,
      status: order.status,
      hasOrderNumber: !!order.orderNumber,
      hasStatus: !!order.status
    }))
  });
  
  res.json({
    success: true,
    count: orders.length,
    total,
    pagination: {
      currentPage: pageNum,
      totalPages,
      hasNextPage,
      hasPrevPage,
      nextPage: hasNextPage ? pageNum + 1 : null,
      prevPage: hasPrevPage ? pageNum - 1 : null
    },
    data: orders
  });
});

// @desc    Get all orders (Admin)
// @route   GET /api/orders
// @access  Private/Admin
const getOrders = asyncHandler(async (req, res) => {
  const { status, page = 1, limit = 10 } = req.query;
  
  const pageNum = parseInt(page);
  const limitNum = parseInt(limit);
  
  const filter = {};
  if (status) {
    filter.status = status;
  }
  
  const orders = await Order.find(filter)
    .populate('user', 'fullName email')
    .sort({ createdAt: -1 })
    .limit(limitNum)
    .skip((pageNum - 1) * limitNum);
  
  const total = await Order.countDocuments(filter);
  const totalPages = Math.ceil(total / limitNum);
  const hasNextPage = pageNum < totalPages;
  const hasPrevPage = pageNum > 1;
  
  res.json({
    success: true,
    count: orders.length,
    total,
    pagination: {
      currentPage: pageNum,
      totalPages,
      hasNextPage,
      hasPrevPage,
      nextPage: hasNextPage ? pageNum + 1 : null,
      prevPage: hasPrevPage ? pageNum - 1 : null
    },
    data: orders
  });
});

// @desc    Get single order
// @route   GET /api/orders/:id
// @access  Private
const getOrder = asyncHandler(async (req, res) => {
  console.log('üì¶ Getting order with ID:', req.params.id);
  
  const order = await Order.findById(req.params.id)
    .populate('items.product', 'name images')
    .populate('user', 'fullName email');

  console.log('üì¶ Found order:', {
    found: !!order,
    orderId: order?._id,
    orderNumber: order?.orderNumber,
    status: order?.status
  });

  if (!order) {
    console.log('‚ùå Order not found');
    return res.status(404).json({
      success: false,
      message: 'Order not found'
    });
  }

  // Debug logging
  console.log('üì¶ Order debug:', {
    orderId: order._id,
    orderNumber: order.orderNumber,
    status: order.status,
    hasOrderNumber: !!order.orderNumber,
    hasStatus: !!order.status,
    user: order.user?._id,
    guestInfo: order.guestInfo
  });

  // Check if user owns this order or is admin
  console.log('üì¶ Authorization check:', {
    orderUserId: order.user?._id?.toString(),
    requestUserId: req.user.id,
    userRole: req.user.role,
    hasOrderUser: !!order.user,
    isOwner: order.user && order.user._id.toString() === req.user.id,
    isAdmin: req.user.role === 'admin'
  });
  
  if (order.user && order.user._id.toString() !== req.user.id && req.user.role !== 'admin') {
    console.log('‚ùå Authorization failed');
    return res.status(403).json({
      success: false,
      message: 'Not authorized to view this order'
    });
  }

  console.log('üì¶ Sending order response:', {
    orderId: order._id,
    orderNumber: order.orderNumber,
    status: order.status,
    hasOrderNumber: !!order.orderNumber,
    hasStatus: !!order.status
  });

  res.json({
    success: true,
    data: { order }
  });
});

// @desc    Update order status
// @route   PUT /api/orders/:id/status
// @access  Private
const updateOrderStatus = asyncHandler(async (req, res) => {
  const { status, note } = req.body;
  
  console.log('üì¶ Update order status request:', {
    orderId: req.params.id,
    status,
    userId: req.user.id,
    userRole: req.user.role
  });
  
  const order = await Order.findById(req.params.id);
  if (!order) {
    return res.status(404).json({
      success: false,
      message: 'Order not found'
    });
  }
  
  console.log('üì¶ Found order:', {
    orderId: order._id,
    orderUserId: order.user,
    orderStatus: order.status,
    canBeCancelled: order.canBeCancelled ? order.canBeCancelled() : 'method not found'
  });

  // Check authorization
  const orderUserId = order.user ? order.user.toString() : order.user;
  console.log('üîê Authorization check:', {
    orderUserId,
    requestUserId: req.user.id,
    userRole: req.user.role,
    isAdmin: req.user.role === 'admin',
    isOwner: orderUserId === req.user.id,
    canUpdate: orderUserId === req.user.id || req.user.role === 'admin'
  });
  
  if (orderUserId && orderUserId !== req.user.id && req.user.role !== 'admin') {
    console.log('‚ùå Authorization failed:', {
      orderUserId,
      requestUserId: req.user.id,
      userRole: req.user.role,
      isAdmin: req.user.role === 'admin'
    });
    return res.status(403).json({
      success: false,
      message: 'Not authorized to update this order'
    });
  }

  // Check if order can be cancelled (only for customers)
  if (status === 'cancelled' && req.user.role !== 'admin') {
    if (!order.canBeCancelled()) {
      return res.status(400).json({
        success: false,
        message: 'Order cannot be cancelled at this stage'
      });
    }
  }

  await order.updateStatus(status, note, req.user.id);

  // Send status update email
  try {
    const { sendEmail } = require('../services/emailService');
    
    // Get customer info
    let customerEmail, customerName;
    if (order.user) {
      const user = await require('../models/User').findById(order.user);
      customerEmail = user.email;
      customerName = user.fullName;
    } else if (order.guestInfo) {
      customerEmail = order.guestInfo.email;
      customerName = order.guestInfo.fullName;
    }
    
    if (customerEmail) {
      const statusMessages = {
        'pending': 'Your order is being processed',
        'confirmed': 'Your order has been confirmed and is being prepared',
        'processing': 'Your order is being processed',
        'shipped': 'Your order has been shipped',
        'delivered': 'Your order has been delivered',
        'cancelled': 'Your order has been cancelled',
        'returned': 'Your order has been returned'
      };
      
      const emailMessage = `
Dear ${customerName},

Your order status has been updated.

Order Details:
- Order Number: ${order.orderNumber}
- New Status: ${status}
- Message: ${statusMessages[status] || 'Status updated'}
${note ? `- Note: ${note}` : ''}

${status === 'shipped' ? 'Your order is on its way! You can track your order using the tracking number provided.' : ''}
${status === 'delivered' ? 'Your order has been successfully delivered. Thank you for your purchase!' : ''}
${status === 'cancelled' ? 'Your order has been cancelled. If you have any questions, please contact our support team.' : ''}

Thank you for choosing our store!

Best regards,
TechStore Team
      `;
      
      await sendEmail({
        email: customerEmail,
        subject: `Order Status Update - ${order.orderNumber}`,
        message: emailMessage
      });
      
      console.log('üìß Order status update email sent to:', customerEmail);
    }
  } catch (error) {
    console.error('‚ùå Failed to send status update email:', error);
    // Don't fail the status update if email fails
  }

  res.json({
    success: true,
    message: 'Order status updated successfully',
    data: { order }
  });
});

module.exports = {
  createOrder,
  getMyOrders,
  getOrders,
  getOrder,
  updateOrderStatus
};
